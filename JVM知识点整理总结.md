 ## JVM知识点整理总结

###一、JVM内存模型？

程序计数器: 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此为了线程切换后能恢复到正确的执行位置，每条线程都需要独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

虚拟机栈: 与程序计数器一样，也是线程私有的，它的生命周期与线程相同，每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。在Java虚拟机规范中，对这个区域规定了两种异常状况：1.如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。2.如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

本地方法栈：与虚拟机方法栈的区别是虚拟机方法栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务，在HotSpot虚拟机中直接就把本地方法栈和虚拟机方法栈合二为一。

Java堆: 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，堆是垃圾收集器管理的主要区域。堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，可通过-Xmx和-Xms控制扩展，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时将会抛出OutOfMemoryError异常。

方法区: 与堆一样是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

###二、对象探秘

####1. 对象的创建

虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。

根据Java堆的内存是否规整，决定不同的分配内存方式。如果是绝对规整的，所有用过的内存都放到一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式成为“指针碰撞”。如果并不是规整的，已使用的内存和空闲的内存相互交错，虚拟机就必须维护一个列表，记录那些内存块是可用，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式叫“空闲列表”。而Java堆是否规整又由垃圾收集器是否带有压缩整理功能决定。

除了分配空间问题外，还要考虑在并发情况下线程安全问题，解决方案有两种：一种是对分配内存空间的动作进行同步处理—实际上虚拟机采用CAS(Compare and Swap，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当旧预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。)配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆预先分配一小块内存，称为本地线程分配缓冲，可以通过-XX:+/-UseTLAB参数设定是否启用。

最后一个对象产生以后，对象的创建才刚刚开始，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个对象的创建才算完成。

#### 2.对象的内存布局

在HotSpot虚拟机中，对象在内存中存储的布局分为3块区域：对象头、实例数据、对齐填充。

HotSpot虚拟机的对象头包括两部分信息：

1. 用于存储对象自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称它为“Mark Word”。例如：如果对象处于未被锁定的状态下，Mark Word的32bit空间中25bit用于存储对象的HashCode，4bit用于存储对象的分代年龄，2bit用于存储锁标志位，1bit固定为0。

2. 对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

   ​

实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。

对齐填充部分并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。

#### 3.对象的访问定位

当要使用对象时，Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以这个取决于虚拟机的实现而定。目前主流的访问方式有使用句柄和直接指针两种。

如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

如果使用直接指针访问，那么Java堆中存储的是对象实例对象，reference中存储的直接就是对象地址，而对象实例数据中还会存储到对象类型数据的指针，指向方法区的对象类型数据。

两种方式各有优势，使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中的实例数据指针，而reference本身不需要修改。

使用直接指针访问的方式最大的好处就是速度更快，节省了一次指针定位的时间开销。HotSpot就是使用该种方式进行对象访问的。



### 三、垃圾收集器

垃圾回收主要针对的是Java堆和方法区，程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的。

**判断对象是否存活**

判断对象是否存活主要有两种算法，分别是：

1. 引用计数算法

   所谓引用计数算法是指：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。微软COM技术、Python等都是使用该算法进行内存管理的。Java没有使用该算法来实现内存管理，最主要原因是它很难解决对象之间的相互循环引用问题。

2. 可达性分析算法

   这个算法基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象是不可用的。

   在Java语言中，可作为GC Roots的对象包括以下几种：

   - 虚拟机栈中引用的对象。
   - 方法区中类静态属性引用的对象
   - 方法区中常量引用的对象
   - 本地方法栈中JNI（即一般说的Native方法）引用的对象

其中在Java中引用又分为几类：强引用、软引用、弱引用、虚引用，4种引用强度依次减弱。

- 强引用是代码中普遍存在的，类似“Object obj = new Object()”，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够内存，才会抛出内存溢出异常，通过用SoftReference类来实现软引用。
- 弱引用也是用来描述非必需对象的，但是强度比软引用更弱，只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象，通过用WeakReference类来实现弱引用。
- 虚引用也成幽灵引用。一个对象是否有虚引用的存在，不会对其生存时间构成影响，也无法通过虚引用来取得对象实例，为对象设置虚引用的唯一目的就是能在对象被收集器回收时收到系统通知，通过用PhantomReference类来实现虚引用。

**对象的生存与死亡**

即使是可达性分析算法中不可达的对象，也并非是“非死不可”的，要真正宣告一个对象的死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的对列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但是并不承诺会等待它运行结束。稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己—只要重新与引用链上任何一个对象建立关联即可，那在第二次标记时它将被移除出“即将回收”的集合，如果对象这时候还没有逃脱，那基本上它就真的被回收了。还有一点要注意的是，任何一个对象的finalize()方法都只会被系统自动调用一次。

**回收方法区**

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。但是判断一个类是否是“无用的类”需要满足下面三个条件：

1. 该类所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。
2. 加载该类的ClassLoader已经被回收。
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

这里说的“可以”并不像对象一样，不使用了就必然被回收。

####1. 垃圾收集算法

##### 1.1 标记-清除算法

最基础的收集算法是标记-清除算法，算法分为“标记”和“清除”两个阶段：具体标记过程前面已经有具体阐述，在标记完成后统一回收所有被标记的对象。它的主要不足有两处：一是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一个垃圾收集动作。

##### 1.2 复制算法

该算法的思想是将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。这种算法的代价是将内存缩小为了原来的一半，未免太高了点。

现在商业虚拟机都采用这种收集算法来回收新生代，但并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，也就是每次新生代中可用内存空间为整个新生代容量的90%，只有10%的内存会被浪费。当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。

##### 1.3 标记—整理算法

该算法一般适合用来做老年代的收集，标记过程跟“标记—清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

##### 1.4 分代收集算法

这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老生代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。

#### 2.HotSpot的算法实现

##### 2.1 枚举根节点

可达性分析对执行时间的敏感体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行—这里"一致性"的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用的关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证，这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事称为“Stop the world”）的其中一个重要原因。

当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机是有办法直接得知哪些地方存放着对象引用。在HotSpot实现中，是使用一组称为OopMap（Ordinary Object Pointer Map）的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来。这样，GC在扫描时就可以直接得知这些信息了。

##### 2.2 安全点

在OopMap的协助下，HotSpot可以快速且准确地完成GC Root枚举，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。

