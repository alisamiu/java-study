## 面试题总结

### 1. 微信随机红包算法实现

```
public static double getRandomMoney(RedPackage _redPackage) {
    // remainSize 剩余的红包数量
    // remainMoney 剩余的钱
    if (_redPackage.remainSize == 1) {
        _redPackage.remainSize--;
        return (double) Math.round(_redPackage.remainMoney * 100) / 100;
    }
    Random r     = new Random();
    double min   = 0.01; //
    double max   = _redPackage.remainMoney / _redPackage.remainSize * 2;
    double money = r.nextDouble() * max; //该方法的作用是生成一个随机的double值，数值介于[0,1.0)之间。
    money = money <= min ? 0.01: money;
    money = Math.floor(money * 100) / 100;//floor()取不大于的最大整数
    _redPackage.remainSize--;
    _redPackage.remainMoney -= money;
    return money;
} //该算法概率均等又符合随机
```

### 2. web攻击

#### 2.1 XSS攻击

xss攻击是跨站脚本攻击。恶意攻击者往Web页面里注入恶意Script代码，当用户浏览这些网页时，就会执行其中的恶意代码，可对用户进行盗取cookie信息、会话劫持等各种攻击。XSS是常见的Web攻击技术之一，由于跨站脚本漏洞易于出现且利用成本低，所以被OWASP列为当前的头号Web安全威胁。 

可以将XSS分为3类： (1) 反射型XSS(Non-persistent XSS)，服务器接受客户端的请求包，不会存储请求包的内容，只是简单的把用户输入的数据“反射”给浏览器。(2) 存储型XSS(Persistent XSS)，这类XSS攻击会把用户输入的数据“存储”在服务器端，具有很强的稳定性。注入脚本跟反射型XSS大同小异，只是脚本不是通过浏览器à服务器à浏览器这样的反射方式，而是多发生在富文本编辑器、日志、留言、配置系统等数据库保存用户输入内容的业务场景。即用户的注入脚本保存到了数据库里，其他用户进行访问涉及到包含恶意脚本的链接都会中招。(3) DOM based XSS(Document Object Model XSS)，这类XSS攻击者将攻击脚本注入到DOM 结构里。出现该类攻击的大多原因是含JavaScrip静态HTML页面存在XSS漏洞。

XSS攻击的危害，可以将XSS分为3类：(1) 窃取用户信息。黑客可以利用跨站脚本漏洞盗取用户cookie而得到用户在该站点的身份权限。(2) 劫持浏览器会话来执行恶意操作，如进行非法转账、强制发表日志或电子邮件等。(3) 强制弹广告页，刷流量和点击率。(4) 传播跨站脚本蠕虫。如著名的Samy (XSS)蠕虫攻击、新浪微博蠕虫攻击。

对于XSS攻击，我们可以做如下防范：(1) 输入过滤。永远不要相信用户的输入，对用户输入的数据做一定的过滤。如输入的数据是否符合预期的格式，比如日期格式，Email格式，电话号码格式等等。这样可以初步对XSS漏洞进行防御。(2) 输出编码。服务器端输出到浏览器的数据，可以使用系统的安全函数来进行编码或转义来防范XSS攻击。(3) HttpOnly Cookie。预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。(4))WAF(Web Application Firewall)，Web应用防火墙，主要的功能是防范诸如网页木马、XSS以及CSRF等常见的Web漏洞攻击。由第三方公司开发，在企业环境中深受欢迎。

#### 2.2 CSRF攻击

CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击。例如，小明在浏览银行A网站的时候并没有关掉银行网站，这时小明又访问了携带CSRF攻击的B网站，而这时候B网站通过对银行的服务器发送转账请求，并且携带小明的在银行网站的cookie信息，在参数上把小明账号上的钱转到B网站所有人的账户上，这时url得到响应，小明的钱就丢了。

对于CSRF攻击，我们可以做如下防范：(1) 验证码。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。(2) Referer Check。HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。(3) Anti CSRF Token。目前比较完善的解决方案是加入Anti-CSRF-Token，即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。

#### 2.3 DoS攻击/DDos攻击

要理解Dos攻击，首先要先明白TCP建立连接的3次握手：Client发送连接请求报文，报文信息包括syn值和seq，Server接收连接后回复ACK报文，并为这次连接分配资源。Client接收到ACK报文后也向Server发送ACK报文，并分配资源。这样TCP连接建立。前两次握手，是为了保证服务端能接收到客户端的信息并能做出正确应答；后两次握手，是为了保证客户端能够接收到服务器的信息并能做出正确应答。

通常攻击者在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN 请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 SYN攻击的问题就出在TCP连接的三次握手中，假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的，从而导致第三次握手无法完成。在这种情况下服务器端一般会重试，即再次发送SYN+ACK给客户端，并等待一段时间后丢弃这个未完成的连接。这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级，大约为30秒到2分钟。一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源，即数以万计的半连接，将会对服务器的CPU和内存造成极大的消耗。若服务器的TCP/IP栈不够强大，最后的结果往往是堆栈溢出崩溃。实际上，就算服务器端的系统足够强大，服务器端也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求，导致用户的正常请求失去响应。 对于该类问题，我们可以做如下防范： 第一种是缩短SYN Timeout时间，及时将超时请求丢弃，释放被占用CPU和内存资源。 第二种是限制同时打开的SYN半连接数目，关闭不必要的服务。 第三种方法是设置SYN Cookie，给每一个请求连接的IP地址分配一个Cookie。如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被一概丢弃。 一般来说，第三种方法在防范该类问题上表现更佳。同时可以在Web服务器端采用分布式组网、负载均衡、提升系统容量等可靠性措施，增强总体服务能力。

 DDoS(Distributed Denial of Service，分布式拒绝服务)是DoS攻击的一种方法。攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。阻止合法用户对正常网络资源的访问，从而达成攻击者不可告人的目的。DDoS的攻击策略侧重于通过很多“僵尸主机”，向受害主机发送大量看似合法的网络包，从而造成网络阻塞或服务器资源耗尽而导致拒绝服务。 

#### 2.4 SQL注入

SQL注入(SQL Injection)，应用程序在向后台数据库传递SQL(Structured Query Language，结构化查询语言)时，攻击者将SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。防御方式有：1、表单过滤，验证表单提交的合法性，对一些特殊字符进行转义处理。2、数据库权限最小化。3、查询语句使用数据库提供的参数化查询接口，不要直接拼接SQL。



### 3. B树、B-树、B+树结构和原理

B树又名平衡多路查找树。B树规则如下：

  (1）树种的每个节点最多拥有m个子节点且m>=2,空树除外（注：m阶代表一个树节点最多有多少个查找路径，m阶=m路,当m=2则是2叉树,m=3则是3叉）；

（2）除根节点外每个节点的关键字数量大于等于ceil(m/2)-1个小于等于m-1个，非根节点关键字数必须>=2;（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2)

（3）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子

（4）如果一个非叶节点有N个子节点，则该节点的关键字数等于N-1;

（5）所有节点关键字是按递增次序排列，并遵循左小右大原则；

![屏幕快照 2018-04-13 下午6.47.29](https://ws3.sinaimg.cn/large/006tKfTcly1fqb81xjyvlj312y0gidhb.jpg)

B树的特点：

B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;



B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。B+树与B树的主要区别：

（1）B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，这样使得B+树每个节点所能保存的关键字大大增加；

（2）B+树叶子节点保存了父节点的所有关键字和关键字记录的指针，每个叶子节点的关键字从小到大链接；

（3）B+树的根节点关键字数量和其子节点个数相等;

（4）B+的非叶子节点只进行数据索引，不会存实际的关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；

![屏幕快照 2018-04-13 下午6.52.32](https://ws2.sinaimg.cn/large/006tKfTcly1fqb865d1ulj30ze0lm0x0.jpg)

特点：

在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定。

###4. Mybatis的#和$的区别

动态 SQL 是 mybatis 的强大特性之一，也是它优于其他 ORM 框架的一个重要原因。mybatis 在对 sql 语句进行预编译之前，会对 sql 进行动态解析，解析为一个 BoundSql 对象，也是在此处对动态 SQL 进行处理的。在动态 SQL 解析阶段， #{ } 和 ${会有不同的表现。${} 在动态解析的时候， 会解析成一个参数标记符。${}在动态解析的时候，会将我们传入的参数当做String字符串填充到我们的语句中。预编译之前的 SQL 语句已经不包含变量了，完全已经是常量数据了。相当于我们普通没有变量的sql了。

综上所得， ${ } 变量的替换阶段是在动态 SQL 解析阶段，而 #{ }变量的替换是在 DBMS 中。除了这个主要区别，还有：

- \#方式能够很大程度防止sql注入。
- $方式无法防止Sql注入。
- $方式一般用于传入数据库对象，例如传入表名.
- **一般能用#的就别用$.**



### 5. HTTPS的连接过程

http通信存在的问题：

- 容易被监听

  http通信都是明文，数据在客户端与服务器通信过程中，任何一点都可能被劫持。

- 容易被伪装

  http通信时，无法保证通行双方是合法的，通信方可能是伪装的。

- 容易被篡改

  hacker中间篡改数据后，接收方并不知道数据已经被更改。

  ​

共享密钥加密和公开密钥加密

- 共享密钥加密（对称加密）  

  ​        共享密钥的加密密钥和解密密钥是相同的，所以又称为对称密钥

- 公开密钥加密（非对称加密）

  ​        加密算法是公开的，密钥是保密的。公开密钥分为私有密钥和公有密钥，公有密钥是公开的，任何人(客             户端)都可以获取，客户端使用公有密钥加密数据，服务端用私有密钥解密数据。

共享密钥加密与公开密钥加密相比，加解密处理速度快，但公开密钥更适应互联网下使用。



https很好的解决了http的三个缺点（被监听、被篡改、被伪装），https不是一种新的协议，它是http+SSL（TSL）的结合体，SSL是一种独立协议，可以和其他协议比如smtp等结合使用。https改变了通信方式，它由以前的http—>tcp改为http—>SSL—>tcp；https采用了共享密钥加密+公开密钥加密方式。

- 防监听 

  数据是加密的，所以监听得到的数据是密文，hacker看不懂。

- 防伪装

   伪装分为客户端伪装和服务器伪装，通信双方携带证书，证书相当于身份证，有证书就认为合法，没有证书就认为非法，证书由第三方颁布，很难伪造。

- 防篡改

   https对数据做了摘要，篡改数据会被感知到。hacker即使从中改了数据也白搭。

服务器端需要认证的通信过程

![屏幕快照 2018-04-14 下午7.43.27](https://ws4.sinaimg.cn/large/006tKfTcly1fqcfgw1cfyj30z00nwak1.jpg)



1. 客户端发送请求到服务器端
2. 服务端返回证书和公开密钥，公开密钥作为证书的一部分而存在
3. 客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端
4. 服务器使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端
5. 客户端使用共享密钥解密数据
6. SSL加密建立

怎样保证公开密钥的有效性 

- 你也许会想到，怎么保证客户端收到的公开密钥是合法的，不是伪造的，证书很好的完成了这个任务。证书由权威的第三方机构颁发，并且对公开密钥做了签名。

https的缺点：https保证了通信的安全，但带来了加密解密消耗计算机cpu资源的问题 ，不过，有专门的https加解密硬件服务器。

HTTPS标准端口443，HTTP标准端口80